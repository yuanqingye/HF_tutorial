http://stackoverflow.com/questions/6455359/creating-a-mock-httpservletrequest-out-of-a-url-string
Simplest ways to mock an HttpServletRequest:

Create an anonymous subclass:

HttpServletRequest mock = new HttpServletRequest ()
{
    private final Map<String, String[]> params = /* whatever */

    public Map<String, String[]> getParameterMap()
    {
        return params;
    }

    public String getParameter(String name)
    {
        String[] matches = params.get(name);
        if (matches == null || matches.length == 0) return null;
        return matches[0];
    }

    // TODO *many* methods to implement here
};
Use jMock, Mockito, or some other general-purpose mocking framework:

HttpServletRequest mock = context.mock(HttpServletRequest.class); // jMock
HttpServletRequest mock2 = Mockito.mock(HttpServletRequest.class); // Mockito
Use HttpUnit's ServletUnit and don't mock the request at all.

Spring has just that

http://static.springsource.org/spring/docs/3.0.x/api/org/springframework/mock/web/MockHttpServletRequest.html
EDIT: it's in the spring-test module (if you are using maven).

assertThat(objectUnderTest, is(not(someOtherObject)));
assertThat(objectUnderTest, not(someOtherObject));
assertThat(objectUnderTest, not(equalTo(someOtherObject)));
All three options are equivalent, choose the one you find most readable.
To use the simple names of the methods (and allow this tense syntax to work), you need these imports:
import static org.junit.Assert.*;
import static org.hamcrest.CoreMatchers.*;
@RunWith(PowerMockRunner.class)
// We prepare PartialMockClass for test because it's final or we need to mock private or static methods
@PrepareForTest(PartialMockClass.class)
public class YourTestCase {
    @Test
    public void privatePartialMockingWithPowerMock() {        
        PartialMockClass classUnderTest = PowerMockito.spy(new PartialMockClass());

        // use PowerMockito to set up your expectation
        PowerMockito.doReturn(value).when(classUnderTest, "methodToMock", "parameter1");

        // execute your test
        classUnderTest.execute();

        // Use PowerMockito.verify() to verify result
        PowerMockito.verifyPrivate(classUnderTest, times(2)).invoke("methodToMock", "parameter1");
    }
}

@RunWith(PowerMockRunner.class)
// We prepare PartialMockClass for test because it's final or we need to mock private or static methods
@PrepareForTest(PartialMockClass.class)
public class YourTestCase {
    @Test
    public void spyingWithPowerMock() {        
        PartialMockClass classUnderTest = PowerMockito.spy(new PartialMockClass());

        // use Mockito to set up your expectation
        Mockito.when(classUnderTest.methodToMock()).thenReturn(value);

        // execute your test
        classUnderTest.execute();

        // Use Mockito.verify() to verify result
        Mockito.verify(mockObj, times(2)).methodToMock();
    }
}

verify(dependency, never()).someMethod()

The tutorial for easymock:
http://devlearnings.wordpress.com/2010/05/13/easymock-expectationeasymock-expect-flavours-explained/
1 expect and return: return value
2 expect and answer: run a series of procedure
3 expect and delegate: run the same method on some other object(must implement the same public interface)
4 expect and throw : throw exception


On top of that, since EasyMock 3.3, if you need to use another runner on you tests, a JUnit rule is also available to you. 
Both have the exact same behavior. Choosing one of the other is a matter of taste.

import static org.easymock.EasyMock.*; 
import org.easymock.EasyMockRule; 
import org.easymock.TestSubject; 
import org.easymock.Mock; 
import org.junit.Rule; 
import org.junit.Test; 

public class ExampleTest {

  @Rule 
  public EasyMockRule mocks = new EasyMockRule(this); 
  
  @TestSubject 
  private ClassUnderTest classUnderTest = new ClassUnderTest(); 
  
  @Mock 
  private Collaborator mock; 
  
  @Test 
  public void testRemoveNonExistingDocument() {
    replay(mock); 
    classUnderTest.removeDocument("Does not exist"); 
  } 
  
  http://easymock.org/user-guide.html
  guide for using easymock(nice mock return stub method,normal mock and strict mock fail to call any method not set up)
  the call before replay is the method to be verified, you may use expectLastCall().times(3) to make sure how many times being called
  
  C cMock = Mockito.spy(new C());
  Mockito.doNothing().when(cMock).m1();

  Helpful tutorial for mockito:
  http://docs.mockito.googlecode.com/hg/org/mockito/Mockito.html#5