http://stackoverflow.com/questions/6455359/creating-a-mock-httpservletrequest-out-of-a-url-string
Simplest ways to mock an HttpServletRequest:

Create an anonymous subclass:

HttpServletRequest mock = new HttpServletRequest ()
{
    private final Map<String, String[]> params = /* whatever */

    public Map<String, String[]> getParameterMap()
    {
        return params;
    }

    public String getParameter(String name)
    {
        String[] matches = params.get(name);
        if (matches == null || matches.length == 0) return null;
        return matches[0];
    }

    // TODO *many* methods to implement here
};
Use jMock, Mockito, or some other general-purpose mocking framework:

HttpServletRequest mock = context.mock(HttpServletRequest.class); // jMock
HttpServletRequest mock2 = Mockito.mock(HttpServletRequest.class); // Mockito
Use HttpUnit's ServletUnit and don't mock the request at all.

Spring has just that

http://static.springsource.org/spring/docs/3.0.x/api/org/springframework/mock/web/MockHttpServletRequest.html
EDIT: it's in the spring-test module (if you are using maven).

assertThat(objectUnderTest, is(not(someOtherObject)));
assertThat(objectUnderTest, not(someOtherObject));
assertThat(objectUnderTest, not(equalTo(someOtherObject)));
All three options are equivalent, choose the one you find most readable.
To use the simple names of the methods (and allow this tense syntax to work), you need these imports:
import static org.junit.Assert.*;
import static org.hamcrest.CoreMatchers.*;
@RunWith(PowerMockRunner.class)
// We prepare PartialMockClass for test because it's final or we need to mock private or static methods
@PrepareForTest(PartialMockClass.class)
public class YourTestCase {
    @Test
    public void privatePartialMockingWithPowerMock() {        
        PartialMockClass classUnderTest = PowerMockito.spy(new PartialMockClass());

        // use PowerMockito to set up your expectation
        PowerMockito.doReturn(value).when(classUnderTest, "methodToMock", "parameter1");

        // execute your test
        classUnderTest.execute();

        // Use PowerMockito.verify() to verify result
        PowerMockito.verifyPrivate(classUnderTest, times(2)).invoke("methodToMock", "parameter1");
    }
}

@RunWith(PowerMockRunner.class)
// We prepare PartialMockClass for test because it's final or we need to mock private or static methods
@PrepareForTest(PartialMockClass.class)
public class YourTestCase {
    @Test
    public void spyingWithPowerMock() {        
        PartialMockClass classUnderTest = PowerMockito.spy(new PartialMockClass());

        // use Mockito to set up your expectation
        Mockito.when(classUnderTest.methodToMock()).thenReturn(value);

        // execute your test
        classUnderTest.execute();

        // Use Mockito.verify() to verify result
        Mockito.verify(mockObj, times(2)).methodToMock();
    }
}

verify(dependency, never()).someMethod()