1. Load the JDBC driver. To load a driver, you specify the classname 
of the database driver in the Class.forName method. By doing so, 
you automatically create a driver instance and register it with the 
JDBC driver manager. 
2. Define the connection URL. In JDBC, a connection URL specifies 
the server host, port, and database name with which to establish a 
connection. 
3. Establish the connection. With the connection URL, username, 
and password, a network connection to the database can be established. Once the connection is established, database queries can be 
performed until the connection is closed.
4. Create a Statement object. Creating a Statement object enables 
you to send queries and commands to the database. 
5. Execute a query or update. Given a Statement object, you can 
send SQL statements to the database by using the execute, 
executeQuery, executeUpdate, or executeBatch methods. 
6. Process the results. When a database query is executed, a 
ResultSet is returned. The ResultSet represents a set of rows 
and columns that you can process by calls to next and various 
getXxx methods. 
7. Close the connection. When you are finished performing queries 
and processing results, you should close the connection, releasing 
resources to the database. 


Prepare a CallableStatement for the Procedure
You obtain a CallableStatement from a Connection with the prepareCall
method, as below. 
String procedure = "{ ? = call procedure_name( ?, ? ) }";
CallableStatement statement = 
 connection.prepareCall(procedure); 
 
String queryFormat =
"SELECT id FROM music WHERE price < ?";
PreparedStatement statement =
 conn.prepareStatement(queryFormat);
 long startTime = System.currentTimeMillis();
 for(int i=0; i<100; i++) {
statement.setFloat(1, i/4);
 ResultSet results = statement.executeQuery();
 if (print) {
 showResults(results);
 }
 
You must register the JDBC type of each output parameter, using registerOutParameter, as follows,
statement.registerOutParameter(n, type);

The default for a database connection is autocommit; that is, each executed statement is automatically committed to the database. Thus, for transaction management you first need to turn off autocommit for the connection by calling setAutoCommit(false).


Example for executing callable statement
if (_practiceId == null || _collectionsRuleId == null) {
			return null;
		}
		@SuppressWarnings("rawtypes")
		Collection coll = null;
		Connection conn = null;
		CallableStatement cstmt = null;
		ResultSet rs = null;
		try {
			String SQLTEXT = "{call  COLLECTIONS_MODULE.searchCollectionsRule(?, ?, ?)}";
			HFLogger.getLogger().info("SQL := " + SQLTEXT);
			conn = getConnection();
			cstmt = conn.prepareCall(SQLTEXT);
			cstmt.setLong(1, _practiceId);
			cstmt.setLong(2, _collectionsRuleId);			
			cstmt.registerOutParameter(3, OracleTypes.CURSOR);
			cstmt.execute();
			rs = (ResultSet) cstmt.getObject(3);
			coll = getCollection(rs);
			return (List<Charge>) coll;
		} catch (SQLException e) {
			throw new InfrastructureException(e);
		} finally {			
			closeAll(conn, cstmt, null);
			if (rs != null) {
				try {
					rs.close();
				} catch (SQLException e) {					
					e.printStackTrace();
				}
			}
		}
	 